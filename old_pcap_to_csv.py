# Imports Scapy
from scapy.all import *

# Imports csv
import csv


#Create constants

#File to read from
PCAP_FILENAME = "botnet-capture-20110810-neris.pcap"

#File to write TCP data to 
TCP_FILENAME = "TCP_13.csv"

#File to write UDP data to
UDP_FILENAME = 'UDP_13.csv'

#File to wtire ARP data to
ARP_FILENAME = 'ARP_13.csv'


# Gets smac(Ethernet src)
def get_smac(pkt):
    smac = ""
    if pkt.haslayer(Ether):
        smac = pkt[Ether].src
    return smac


# Gets dmac(Ethernet dst)
def get_dmac(pkt):
    dmac = ""
    if pkt.haslayer(Ether):
        dmac = pkt[Ether].dst
    return dmac


# Gets source IP Address
def get_source_ip(pkt):
    source = ""
    if IP in pkt:
        source=pkt[IP].src
    return source


# Gets destination IP Address
def get_dest_ip(pkt):
    destination = ""
    if IP in pkt:
        destination=pkt[IP].dst
    return destination


# Gets ttl for IP
def get_ttl(pkt):
    ttl = ""
    if pkt.haslayer('IP'):
        ttl = pkt[IP].ttl
    return ttl


# Processes packets individually
def process_pkt(pkt, writer_dict):
    # Checks if the pakcet has layer TCP if so writes its info to TCP.csv
    if pkt.haslayer('TCP'):
        length = (len(pkt))
        time = pkt.time
        sMac = get_smac(pkt)
        dMac = get_dmac(pkt)
        srcIP = get_source_ip(pkt)
        dstIP = get_dest_ip(pkt)
        ttl = get_ttl(pkt)
        sPort = pkt[TCP].sport
        dPort = pkt[TCP].dport
        seq = pkt[TCP].seq
        ack = pkt[TCP].ack
        protocol = 'TCP'
        writer_dict["tcp"].writerow([time, sMac, dMac, srcIP, dstIP, ttl, 
                             sPort, dPort, seq, ack, protocol, length])

    # Checks if the packet has layer ARP if so writes its info to ARP.csv
    elif pkt.haslayer('ARP'):
        length = (len(pkt))
        time = pkt.time
        smac = get_smac(pkt)
        dmac = get_dmac(pkt)
        hwsrc = pkt[ARP].hwsrc
        psrc = pkt[ARP].psrc
        hwdst = pkt[ARP].hwdst
        pdst = pkt[ARP].pdst
        protocol = 'ARP'
        writer_dict["arp"].writerow([time, smac, dmac, hwsrc, psrc, hwdst, pdst, protocol, length])

    # Checks if the packet has layer UDP and if so writes its info to UDP.csv
    elif pkt.haslayer('UDP'):
        length = (len(pkt))
        time = pkt.time
        sMac = get_smac(pkt)
        dMac = get_dmac(pkt)
        srcIP = get_source_ip(pkt)
        dstIP = get_dest_ip(pkt)
        ttl = get_ttl(pkt)
        sport = pkt[UDP].sport
        dport = pkt[UDP].dport
        protocol = 'UDP'
        info = ""
        # Checks if the packet has layer NBT Datagram Packet and Pulls info for NBT packet if so
        if pkt.haslayer('NBT Datagram Packet'):
            info = pkt['NBT Datagram Packet'].show(dump=True)
            info = info[:info.index('###[ Raw')]
        writer_dict["udp"].writerow([time, sMac, dMac, srcIP, dstIP, ttl, sport, dport, protocol, length, info])


# Opens writers, writes headers to file, and stores writers in a dictionary
with open(TCP_FILENAME, 'w') as tcp_csvfile, open(UDP_FILENAME, 'w') as udp_csvfile, open(ARP_FILENAME, 'w') as arp_csvfile:
    tcp_writer = csv.writer(tcp_csvfile)
    tcp_writer.writerow(['Time', 'smac', 'dmac', 'srcIP', 'dstIP', 'ttl', 
                         'sport', 'dport', 'seq', 'ack', 'Protocol', 'Length'])

    arp_writer = csv.writer(arp_csvfile)
    arp_writer.writerow(['Time', 'smac', 'dmac', 'hwsrc', 'psrc', 'hwdst', 'pdst', 'Protocol', 'Length'])

    udp_writer = csv.writer(udp_csvfile)
    udp_writer.writerow(['Time', 'smac', 'dmac', 'srcIP', 'dstIP', 'ttl', 'sport', 
                         'dport', 'Protocol', 'Length', "Info"])

    writer_dict = {
        "tcp": tcp_writer, 
        "arp": arp_writer, 
        "udp": udp_writer
    }
    
    # Reads in packets, sending them to process_pkt
    # Count is the number of packets to read in
    # Store 0 deletes the packets from memory after they are processed
    sniff(count=100, offline=PCAP_FILENAME, prn=lambda pkt: process_pkt(pkt, writer_dict) , store=0)
    
